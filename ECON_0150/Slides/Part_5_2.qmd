---
format:
  revealjs:
    css: custom.css
    transition: none
    aspect-ratio: "16:9"
---

## ECON 0150 | Economic Data Analysis {.center}
<p class="subheader">The economist's data analysis pipeline.</p>

<br> 

### *Part 5.2 | Time Series: Differences, Seasonality, and Elasticities*

---

## Time Series Analysis 
<p class="subheader">Modeling relationships through time</p>

<br>

**Key Questions:**

- How do we analyze data that changes over time?
- What do trends, cycles, and seasonal patterns tell us?
- How do we transform time series data for the general linear model?

---

## The Challenge of Time Series
<p class="subheader">Data related in time has a special problem of autocorrelation.</p>

```{python}
# Visualization of serial correlation in a time series
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.graphics.tsaplots import plot_acf

# Set seed for reproducibility
np.random.seed(42)

# Generate a time series with substantial serial correlation (as before)
n = 100
time = np.arange(n)
random_component = np.random.normal(0, 1, n)

# Create a serially correlated series with AR(1) process
rho = 0.8  # serial correlation parameter
series = np.zeros(n)
series[0] = random_component[0]
for t in range(1, n):
    series[t] = rho * series[t-1] + random_component[t]

# Add a slight upward trend
series += 0.02 * time

# Create 2x1 subplot figure
fig, axs = plt.subplots(1, 1, figsize=(11, 5))

# Plot the time series
axs.plot(time, series, color='blue', linewidth=2)
axs.scatter(time, series, alpha=0.5, color='blue')
axs.set_xlabel('Time (t)')
axs.set_ylabel('Y', rotation=0)
axs.spines['top'].set_visible(False)
axs.spines['right'].set_visible(False)
axs.set_yticks([-3,0,3])

sns.despine(trim=True)

plt.tight_layout()
plt.show()
```

. . .

*> observations are related to their past values (serial correlation; autocorrelation)*

---

## Autocorrelation
<p class="subheader">Values in time series are typically related to their own past values.</p>

. . .

```{python}
# Visualization of autocorrelation in a time series
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
from statsmodels.nonparametric.smoothers_lowess import lowess

# Set seed for reproducibility
np.random.seed(42)

# Generate a time series with substantial serial correlation
n = 120
time = np.arange(n)
random_component = np.random.normal(0, 1, n)

# Create a serially correlated series with AR(1) process
rho = 0.9  # Increased correlation parameter for more visible effect
series = np.zeros(n)
series[0] = random_component[0]
for t in range(1, n):
    series[t] = rho * series[t-1] + random_component[t]

# Add a slight upward trend
series += 0.02 * time

# Create lagged version for scatterplot
current = series[1:]
lagged = series[:-1]

# Create figure
fig, ax = plt.subplots(figsize=(7, 7))

# Plot scatter with alpha for density visualization
ax.scatter(lagged, current, alpha=0.6, color='blue', s=80)

# Add identity line (perfect correlation)
min_val = min(np.min(current), np.min(lagged))
max_val = max(np.max(current), np.max(lagged))
ax.plot([min_val, max_val], [min_val, max_val], color='gray', linestyle='--', alpha=0.4, 
         label='Identity Line (Y$_{t}$ = Y$_{t-1}$)')

# Calculate correlation coefficient
corr = np.corrcoef(lagged, current)[0, 1]

# Add annotation
ax.text(0.05, 0.95, f"Correlation: {corr:.3f}", transform=ax.transAxes, 
        fontsize=14, va='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

# Styling
ax.set_xlabel('Y$_{t-1}$ (Previous Value)', fontsize=14)
ax.set_ylabel('Y$_t$ (Current Value)', fontsize=14)

sns.despine(trim=True)

plt.show()
```

---

## Model 1: Levels Regression
<p class="subheader">The standard approach has problems with time series.</p>

$$\text{Y} = \beta_0 + \beta_1 \times \text{t} + \varepsilon$$

```{python}
# Visualization of serial correlation in a time series
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.graphics.tsaplots import plot_acf

# Set seed for reproducibility
np.random.seed(42)

# Generate a time series with substantial serial correlation (as before)
n = 100
time = np.arange(n)
random_component = np.random.normal(0, 1, n)

# Create a serially correlated series with AR(1) process
rho = 0.8  # serial correlation parameter
series = np.zeros(n)
series[0] = random_component[0]
for t in range(1, n):
    series[t] = rho * series[t-1] + random_component[t]

# Add a slight upward trend
series += 0.02 * time

# Create 2x1 subplot figure
fig, axs = plt.subplots(1, 1, figsize=(11, 5))

# Plot the time series
axs.plot(time, series, color='blue', linewidth=2)
axs.scatter(time, series, alpha=0.5, color='blue')
axs.set_xlabel('Time (t)')
axs.set_ylabel('Y', rotation=0)
axs.spines['top'].set_visible(False)
axs.spines['right'].set_visible(False)
axs.set_yticks([-3,0,3])

# Fit regression line
X = sm.add_constant(time)
model = sm.OLS(series, X).fit()
pred_y = model.predict(X)

# Sort for plotting
axs.plot(time, pred_y[time], color='red', linewidth=2)

# Styling
axs.set_xlabel('Time (t)')
axs.set_ylabel('Y', rotation=0)
axs.spines['top'].set_visible(False)
axs.spines['right'].set_visible(False)
axs.set_yticks([-3,0,3])

sns.despine(trim=True)

plt.tight_layout()
plt.show()
```

---

## OLS Assumption: No Autocorrelation
<p class="subheader">The confidence level of regression requres that the error terms are independent.</p>

```{python}
# Visualization of autocorrelated residuals (only levels regression)
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate time
n = 100
time = np.arange(n)

# Generate two correlated time series with serial correlation
# First series (x)
x_random = np.random.normal(0, 1, n)
x_series = np.zeros(n)
x_series[0] = x_random[0]
for t in range(1, n):
    x_series[t] = 0.8 * x_series[t-1] + x_random[t]
x_series += 0.03 * time  # Add trend

# Second series (y) - correlated with x but with its own dynamics
y_random = np.random.normal(0, 1, n)
y_series = np.zeros(n)
y_series[0] = y_random[0]
for t in range(1, n):
    y_series[t] = 0.75 * y_series[t-1] + 0.4 * x_series[t] + y_random[t]
y_series += 0.02 * time  # Add trend

# Fit time series regression (levels)
X = sm.add_constant(x_series)
model = sm.OLS(y_series, X).fit()
residuals = model.resid

# Create figure - only first row (2 plots)
fig, axs = plt.subplots(1, 2, figsize=(11, 5))

# Plot residuals from levels regression over time
axs[0].plot(time, residuals, color='red')
axs[0].scatter(time, residuals, alpha=0.7, color='red')
axs[0].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[0].set_title('Residuals from Levels Regression', fontsize=12)
axs[0].set_xlabel('Time')
axs[0].set_ylabel('Residual')
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)

# Plot current residual vs lagged residual for levels regression
lagged_resid = residuals[:-1]
current_resid = residuals[1:]
axs[1].scatter(lagged_resid, current_resid, alpha=0.7, color='red')

# Add regression line to show autocorrelation
X_resid = sm.add_constant(lagged_resid)
resid_model = sm.OLS(current_resid, X_resid).fit()
pred_resid = resid_model.predict(X_resid)
sort_idx = np.argsort(lagged_resid)
axs[1].plot(lagged_resid[sort_idx], pred_resid[sort_idx], color='black', linewidth=2)

# Calculate autocorrelation coefficient
autocorr = np.corrcoef(lagged_resid, current_resid)[0, 1]
axs[1].set_title(f'Levels Residuals: Autocorrelation = {autocorr:.2f}', fontsize=12)
axs[1].set_xlabel('Residual(t-1)')
axs[1].set_ylabel('Residual(t)')
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[1].axvline(x=0, color='black', linestyle='--', alpha=0.3)

sns.despine(ax=axs[0], trim=True)
sns.despine(ax=axs[1], trim=True)

plt.tight_layout()
plt.show()
```

. . .

*> levels regression shows strong patterns in residuals (autocorrelation)*

---

## Model 1: Levels Regression
<p class="subheader">The standard approach has problems with time series.</p>

$$\text{Y} = \beta_0 + \beta_1 \times \text{t} + \varepsilon$$

<br>

*> common trends can create spurious correlations*

. . .

*> error terms are serially correlated, violating regression assumptions*

. . .

*> potentially misleading significance levels due to violated assumptions*

. . .

*> differencing substantially reduces the autocorrelation problem*

---

## Model 2: First Differences
<p class="subheader">Focusing on changes rather than levels: $\Delta \text{Y}_t = \text{Y}_t - \text{Y}_{t-1}$</p>

```{python}
# Visualization of first differences transformation
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set seed for reproducibility
np.random.seed(42)

# Generate a time series with substantial serial correlation
n = 101 # Increase to 101 for 100 differences
time = np.arange(n)
random_component = np.random.normal(0, 1, n)

# Create a serially correlated series with AR(1) process
rho = 0.8  # serial correlation parameter
series = np.zeros(n)
series[0] = random_component[0]
for t in range(1, n):
    series[t] = rho * series[t-1] + random_component[t]

# Add a slight upward trend
series += 0.02 * time

# Calculate first differences
diff_series = np.diff(series)
diff_time = time[1:]

# Create figure
fig, axs = plt.subplots(2, 1, figsize=(11, 5))

# Plot the original time series
axs[0].plot(time, series, color='blue', linewidth=2, label='Original')
axs[0].scatter(time, series, alpha=0.5, color='blue')
axs[0].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[0].set_ylabel('$Y_t$', rotation=0, fontsize=14, ha='right')
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)
axs[0].set_yticks([-4,0,4])
axs[0].legend()
sns.despine(ax=axs[0], trim=True)

# Plot the differenced series
axs[1].plot(diff_time, diff_series, color='green', linewidth=2, label='First Differences')
axs[1].scatter(diff_time, diff_series, alpha=0.5, color='green')
axs[1].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[1].set_xlabel('Time (t)', fontsize=12)
axs[1].set_ylabel('$\\Delta Y_t$', rotation=0, fontsize=14, ha='right')
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].set_yticks([-4,0,4])
axs[1].legend()
sns.despine(ax=axs[1], trim=True)

# Align y-axes for better comparison
plt.tight_layout()
plt.show()
```

. . .

*> differences (correctly in this case) shows no relationship*

. . .

*> what would the first differences look like if there was a positive trend?*

---

## Model 2: First Differences
<p class="subheader">Focusing on changes rather than levels: $\Delta \text{Y}_t = \text{Y}_t - \text{Y}_{t-1}$</p>

```{python}
# Visualization of first differences transformation
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set seed for reproducibility
np.random.seed(42)

# Generate a time series with substantial serial correlation
n = 101 # Increase to 101 for 100 differences
time = np.arange(n)
random_component = np.random.normal(0, 1, n)

# Create a serially correlated series with AR(1) process
rho = 0.8  # serial correlation parameter
series = np.zeros(n)
series[0] = random_component[0]
for t in range(1, n):
    series[t] = rho * series[t-1] + random_component[t]

# Add a slight upward trend
series += 2 * time

# Calculate first differences
diff_series = np.diff(series)
diff_time = time[1:]

# Create figure
fig, axs = plt.subplots(2, 1, figsize=(11, 5))

# Plot the original time series
axs[0].plot(time, series, color='blue', linewidth=2, label='Original')
axs[0].scatter(time, series, alpha=0.5, color='blue')
axs[0].set_ylabel('$Y_t$', rotation=0, fontsize=14, ha='right')
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)
axs[0].set_yticks([])
axs[0].legend()
sns.despine(ax=axs[0], trim=True)

# Plot the differenced series
axs[1].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[1].set_xlabel('Time (t)', fontsize=12)
axs[1].set_ylabel('$\\Delta Y_t$', rotation=0, fontsize=14, ha='right')
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].set_yticks([-4,0,4])
sns.despine(ax=axs[1], trim=True)

# Align y-axes for better comparison
plt.tight_layout()
plt.show()
```

---

## Model 2: First Differences
<p class="subheader">Focusing on changes rather than levels: $\Delta \text{Y}_t = \text{Y}_t - \text{Y}_{t-1}$</p>

```{python}
# Visualization of first differences transformation
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set seed for reproducibility
np.random.seed(42)

# Generate a time series with substantial serial correlation
n = 101 # Increase to 101 for 100 differences
time = np.arange(n)
random_component = np.random.normal(0, 1, n)

# Create a serially correlated series with AR(1) process
rho = 0.8  # serial correlation parameter
series = np.zeros(n)
series[0] = random_component[0]
for t in range(1, n):
    series[t] = rho * series[t-1] + random_component[t]

# Add a slight upward trend
series += 2 * time

# Calculate first differences
diff_series = np.diff(series)
diff_time = time[1:]

# Create figure
fig, axs = plt.subplots(2, 1, figsize=(11, 5))

# Plot the original time series
axs[0].plot(time, series, color='blue', linewidth=2, label='Original')
axs[0].scatter(time, series, alpha=0.5, color='blue')
axs[0].set_ylabel('$Y_t$', rotation=0, fontsize=14, ha='right')
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)
axs[0].set_yticks([])
axs[0].legend()
sns.despine(ax=axs[0], trim=True)

# Plot the differenced series
axs[1].plot(diff_time, diff_series, color='green', linewidth=2, label='First Differences')
axs[1].scatter(diff_time, diff_series, alpha=0.5, color='green')
axs[1].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[1].set_xlabel('Time (t)', fontsize=12)
axs[1].set_ylabel('$\\Delta Y_t$', rotation=0, fontsize=14, ha='right')
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].set_yticks([-4,0,4])
axs[1].legend()
sns.despine(ax=axs[1], trim=True)

# Align y-axes for better comparison
plt.tight_layout()
plt.show()
```

. . .

*> the vertical intercept is positive!*

. . .

*> differences (correctly in this case) shows the relationship as an intercept*

---

## The Time Series Challenge
<p class="subheader">The problem of autocorrelated residuals.</p>

```{python}
# Visualization of differenced regression residuals (only second row)
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate time
n = 100
time = np.arange(n)

# Generate two correlated time series with serial correlation
# First series (x)
x_random = np.random.normal(0, 1, n)
x_series = np.zeros(n)
x_series[0] = x_random[0]
for t in range(1, n):
    x_series[t] = 0.8 * x_series[t-1] + x_random[t]
x_series += 0.03 * time  # Add trend

# Second series (y) - correlated with x but with its own dynamics
y_random = np.random.normal(0, 1, n)
y_series = np.zeros(n)
y_series[0] = y_random[0]
for t in range(1, n):
    y_series[t] = 0.75 * y_series[t-1] + 0.4 * x_series[t] + y_random[t]
y_series += 0.02 * time  # Add trend

# Fit differenced time series regression
diff_x = np.diff(x_series)
diff_y = np.diff(y_series)
X_diff = sm.add_constant(diff_x)
model_diff = sm.OLS(diff_y, X_diff).fit()
residuals_diff = model_diff.resid

# Create figure - only second row (2 plots)
fig, axs = plt.subplots(1, 2, figsize=(11, 5))

# Plot residuals from differenced regression over time
axs[0].plot(time[1:], residuals_diff, color='green')
axs[0].scatter(time[1:], residuals_diff, alpha=0.7, color='green')
axs[0].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[0].set_title('Residuals from Differenced Regression', fontsize=12)
axs[0].set_xlabel('Time')
axs[0].set_ylabel('Residual')
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)

# Plot current residual vs lagged residual for differenced regression
lagged_resid_diff = residuals_diff[:-1]
current_resid_diff = residuals_diff[1:]
axs[1].scatter(lagged_resid_diff, current_resid_diff, alpha=0.7, color='green')

# Add regression line to show autocorrelation
X_resid_diff = sm.add_constant(lagged_resid_diff)
resid_diff_model = sm.OLS(current_resid_diff, X_resid_diff).fit()
pred_resid_diff = resid_diff_model.predict(X_resid_diff)
diff_sort_idx = np.argsort(lagged_resid_diff)
axs[1].plot(lagged_resid_diff[diff_sort_idx], pred_resid_diff[diff_sort_idx], color='black', linewidth=2)

# Calculate autocorrelation coefficient
autocorr_diff = np.corrcoef(lagged_resid_diff, current_resid_diff)[0, 1]
axs[1].set_title(f'Differenced Residuals: Autocorrelation = {autocorr_diff:.2f}', fontsize=12)
axs[1].set_xlabel('Residual(t-1)')
axs[1].set_ylabel('Residual(t)')
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].axhline(y=0, color='black', linestyle='--', alpha=0.3)
axs[1].axvline(x=0, color='black', linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()
```

*> differencing substantially reduces the autocorrelation problem*

---

## Model 2: The Code
<p class="subheader">Implementing a first differences regression</p>

. . .

```python
# 1. Create first differences variables
data['gdp_diff'] = data['gdp'].diff()
data['unemployment_diff'] = data['unemployment'].diff() 

# 2. Drop the first row which has NaN due to differencing
data = data.dropna()

# 3. Fit the differences model
model2 = smf.ols('gdp_diff ~ unemployment_diff', data=data).fit()
print(model2.summary().tables[1])
```

---

## Model 3: First Differences Regression
<p class="subheader">Relating changes in X to changes in Y through time (t).</p>

*> we can also relate two time series variables $X$ and $Y$ using differences*

```{python}
# Visualization of differences regression
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate time
n = 101
time = np.arange(n)

# Generate two correlated time series with serial correlation (as before)
# First series (x)
x_random = np.random.normal(0, 1, n)
x_series = np.zeros(n)
x_series[0] = x_random[0]
for t in range(1, n):
    x_series[t] = 0.8 * x_series[t-1] + x_random[t]
x_series += 0.03 * time  # Add trend

# Second series (y) - correlated with x but with its own dynamics
y_random = np.random.normal(0, 1, n)
y_series = np.zeros(n)
y_series[0] = y_random[0]
for t in range(1, n):
    y_series[t] = 0.75 * y_series[t-1] + 0.4 * x_series[t] + y_random[t]
y_series += 0.02 * time  # Add trend

# Calculate first differences
diff_x = np.diff(x_series)
diff_y = np.diff(y_series)

# Create figure
fig, ax = plt.subplots(figsize=(11, 5))

# Plot the differenced data
ax.scatter(diff_x, diff_y, alpha=0.5, color='green')

# Fit regression line to differenced data
X_diff = sm.add_constant(diff_x)
model_diff = sm.OLS(diff_y, X_diff).fit()
pred_y_diff = model_diff.predict(X_diff)

# Sort for plotting
sort_idx = np.argsort(diff_x)
ax.plot(diff_x[sort_idx], pred_y_diff[sort_idx], color='red', linewidth=2)

# Styling
ax.set_xlabel('ΔX', fontsize=12)
ax.set_ylabel('ΔY', fontsize=12)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.set_yticks([-4,0,4])
ax.set_xticks([-4,0,4])
ax.axhline(y=0, color='black', linestyle='--', alpha=0.3)
ax.axvline(x=0, color='black', linestyle='--', alpha=0.3)

sns.despine(ax=ax, offset=10, trim=True)

plt.tight_layout()
plt.show()
```

. . .

$$\Delta \text{Y}_t = \beta_0 + \beta_1 \times \Delta \text{X}_t + \varepsilon_t$$

---

## Model 3: First Differences Regression
<p class="subheader">Relating changes in X to changes in Y.</p>

$$\Delta \text{Y}_t = \beta_0 + \beta_1 \times \Delta \text{X}_t + \varepsilon_t$$

<br>

*> removes trends that could cause spurious correlations*

. . .

*> reduces serial correlation in the error terms*

. . .

*> $\beta_0$ captures time trend in $Y$*

. . .

*> clear interpretation: how do changes in X relate to changes in Y?*

. . .

*> $\beta_1$ captures the short-term relationship between variables*

---

## Model 3: The Code
<p class="subheader">Implementing a first differences regression</p>

```python
# Create first differences variables
data['gdp_diff'] = df['gdp'].diff()
df['unemployment_diff'] = df['unemployment'].diff()

# Drop the first row which has NaN due to differencing
data = data.dropna()

# Fit the differences model
model3 = smf.ols('gdp_diff ~ unemployment_diff', data=data).fit()
print(model3.summary())
```

<br>

. . .

*> β₁ now represents the short-term impact of changes in X on changes in Y*

---

## Model 4: Growth Rates
<p class="subheader">Proportional changes provide interpretable coefficients: $g_Y = \frac{\text{Y}_t - \text{Y}_{t-1}}{\text{Y}_{t-1}} = \frac{\Delta \text{Y}_t}{\text{Y}_{t-1}}$</p>

```{python}
# Visualization of growth rates vs first differences
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set seed for reproducibility
np.random.seed(42)

# Generate exponential growth time series 
n = 101
time = np.arange(n)
growth_rate = 0.05  # 5% growth rate

# Create base series with exponential growth and some noise
base_level = 100  # starting value
exp_series = base_level * (1 + growth_rate) ** time
exp_series *= (1 + 0.03 * np.random.normal(0, 1, n))

# Calculate first differences
abs_diff = np.diff(exp_series)
pct_change = np.diff(exp_series) / exp_series[:-1]  # percentage change

# Create figure
fig, axs = plt.subplots(3, 1, figsize=(11, 6))

# Plot the original time series
axs[0].plot(time, exp_series, color='blue', linewidth=2)
axs[0].scatter(time, exp_series, alpha=0.5, color='blue')
axs[0].set_title('Original Series with Exponential Growth', fontsize=14)
axs[0].set_ylabel('Level')
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)

# Plot the absolute differences
axs[1].plot(time[1:], abs_diff, color='green', linewidth=2)
axs[1].scatter(time[1:], abs_diff, alpha=0.5, color='green')
axs[1].set_title('Absolute Differences (Growing Over Time)', fontsize=14)
axs[1].set_ylabel('Δ Level')
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)

# Plot the percentage changes
axs[2].plot(time[1:], pct_change, color='red', linewidth=2)
axs[2].scatter(time[1:], pct_change, alpha=0.5, color='red')
axs[2].axhline(y=growth_rate, color='black', linestyle='--', alpha=0.6, label='True Growth Rate (5%)')
axs[2].set_title('Percentage Changes (Stationary Around Growth Rate)', fontsize=14)
axs[2].set_xlabel('Time', fontsize=12)
axs[2].set_ylabel('% Change')
axs[2].spines['top'].set_visible(False)
axs[2].spines['right'].set_visible(False)
axs[2].legend()

plt.tight_layout()
plt.show()
```

---

## Model 4: Growth Rate Regression
<p class="subheader">Relating growth in X to growth in Y.</p>

. . .

```{python}
# Visualization of growth rates regression
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate time
n = 101
time = np.arange(n)

# Start with higher base values
base_x = 100
base_y = 200

# Generate two series with exponential growth
# X series with 3% average growth plus noise
growth_rate_x = 0.03
x_series = base_x * (1 + growth_rate_x) ** time
x_series *= (1 + 0.04 * np.random.normal(0, 1, n))

# Y series with 4% average growth plus relation to X plus noise
growth_rate_y = 0.04
y_series = base_y * (1 + growth_rate_y) ** time
# Add some relationship to x_series growth
for t in range(1, n):
    if t > 1:
        x_growth = (x_series[t] - x_series[t-1]) / x_series[t-1]
        y_series[t] *= (1 + 0.5 * x_growth)  # Y growth affected by X growth
y_series *= (1 + 0.03 * np.random.normal(0, 1, n))

# Calculate growth rates
x_growth = np.diff(x_series) / x_series[:-1]
y_growth = np.diff(y_series) / y_series[:-1]

# Create figure
fig, ax = plt.subplots(figsize=(11, 5))

# Plot the growth rate data
ax.scatter(x_growth, y_growth, alpha=0.5, color='red')

# Fit regression line
X_growth = sm.add_constant(x_growth)
model_growth = sm.OLS(y_growth, X_growth).fit()
pred_y_growth = model_growth.predict(X_growth)

# Sort for plotting
sort_idx = np.argsort(x_growth)
ax.plot(x_growth[sort_idx], pred_y_growth[sort_idx], color='blue', linewidth=2)

# Styling
ax.set_xlabel('X Growth Rate', fontsize=12)
ax.set_ylabel('Y Growth Rate', fontsize=12)
ax.set_title('Growth Rate Regression', fontsize=14)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.axhline(y=0, color='black', linestyle='--', alpha=0.3)
ax.axvline(x=0, color='black', linestyle='--', alpha=0.3)

plt.tight_layout()
plt.show()
```

. . .

$$g_Y = \beta_0 + \beta_1 \times g_X + \varepsilon_t$$

---

## Model 4: Growth Rate Regression
<p class="subheader">Relating growth in X to growth in Y.</p>

$$g_Y = \beta_0 + \beta_1 \times g_X + \varepsilon_t$$

<br>

*> advantages of first differences plus better scale properties*

. . .

*> natural for variables with exponential growth*

. . .

*> $\beta_0$ is Y's baseline growth rate*

. . .

*> $\beta_1$ is how Y's growth responds to a 1 percentage point increase in X's growth*

---

## Model 4: The Code
<p class="subheader">Implementing a growth rates regression</p>

```python
# Calculate growth rates (percentage changes)
data['gdp_growth'] = data['gdp'].pct_change() # in percentage points
data['unemployment_growth'] = data['unemployment'].pct_change()

# Drop rows with NaN values
data = data.dropna()

# Fit the growth rate model
model4 = smf.ols('gdp_growth ~ unemployment_growth', data=data).fit()
print(model4.summary())
```

<br>

. . .

*> $\beta_1$ is now expressed in percentage point terms*

. . .

*> easier to interpret for policy-relevant questions*

---

## Seasonal Patterns in Economic Data
<p class="subheader">Many economic variables follow seasonal patterns.</p>

```{python}
# Visualization of seasonal patterns in economic data
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set seed for reproducibility
np.random.seed(42)

# Generate quarterly data for 10 years (40 quarters)
n = 40
time = np.arange(n)
years = time // 4
quarters = time % 4

# Create a trend component
trend = 0.05 * time

# Create seasonal effects (Q1 typically low, Q3 typically high)
seasonal_pattern = np.array([-0.2, 0.1, 0.3, -0.1])  # Quarterly seasonal pattern
seasonal = np.array([seasonal_pattern[q] for q in quarters])

# Create a cyclical component (business cycle of ~5 years)
cycle = 0.3 * np.sin(2 * np.pi * time / 20)

# Add all components with some noise
series = trend + seasonal + cycle + 0.1 * np.random.normal(0, 1, n)
series = 100 * np.exp(series)  # Convert to exponential for more realistic scaling

# Create figure
fig, axs = plt.subplots(2, 1, figsize=(11, 5))

# Plot the time series
axs[0].plot(time, series, color='blue', linewidth=2)
axs[0].scatter(time, series, alpha=0.7, color='blue')
for year in range(10):
    if year < 9:  # Don't add line after the last year
        axs[0].axvline(x=year*4 + 3.5, color='gray', linestyle='--', alpha=0.5)

# Add year labels between the vertical lines
for year in range(10):
    axs[0].text(year*4 + 1.5, np.max(series) + 5, f"Year {year+1}", 
                fontsize=10, ha='center')

axs[0].set_title('Quarterly Economic Data with Seasonality', fontsize=14)
axs[0].set_ylabel('Value')
axs[0].set_xticks([])
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)

# Plot the seasonal patterns
# Group by quarter and calculate mean
q_means = [np.mean(series[quarters == q]) for q in range(4)]

axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].spines['bottom'].set_visible(False)
axs[1].spines['left'].set_visible(False)
axs[1].set_xticks([])
axs[1].set_yticks([])

plt.tight_layout()
plt.show()
```

---

## Seasonal Patterns in Economic Data
<p class="subheader">Many economic variables follow seasonal patterns.</p>

```{python}
# Visualization of seasonal patterns in economic data
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set seed for reproducibility
np.random.seed(42)

# Generate quarterly data for 10 years (40 quarters)
n = 40
time = np.arange(n)
years = time // 4
quarters = time % 4

# Create a trend component
trend = 0.05 * time

# Create seasonal effects (Q1 typically low, Q3 typically high)
seasonal_pattern = np.array([-0.2, 0.1, 0.3, -0.1])  # Quarterly seasonal pattern
seasonal = np.array([seasonal_pattern[q] for q in quarters])

# Create a cyclical component (business cycle of ~5 years)
cycle = 0.3 * np.sin(2 * np.pi * time / 20)

# Add all components with some noise
series = trend + seasonal + cycle + 0.1 * np.random.normal(0, 1, n)
series = 100 * np.exp(series)  # Convert to exponential for more realistic scaling

# Create figure
fig, axs = plt.subplots(2, 1, figsize=(11, 5))

# Plot the time series
axs[0].plot(time, series, color='blue', linewidth=2)
axs[0].scatter(time, series, alpha=0.7, color='blue')
for year in range(10):
    if year < 9:  # Don't add line after the last year
        axs[0].axvline(x=year*4 + 3.5, color='gray', linestyle='--', alpha=0.5)

# Add year labels between the vertical lines
for year in range(10):
    axs[0].text(year*4 + 1.5, np.max(series) + 5, f"Year {year+1}", 
                fontsize=10, ha='center')

axs[0].set_title('Quarterly Economic Data with Seasonality', fontsize=14)
axs[0].set_ylabel('Value')
axs[0].set_xticks([])
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)

# Plot the seasonal patterns
# Group by quarter and calculate mean
q_means = [np.mean(series[quarters == q]) for q in range(4)]

axs[1].bar(range(4), q_means, color='green', alpha=0.7)
axs[1].set_ylabel('Average Value')
axs[1].set_xticks(range(4))
axs[1].set_xticklabels(['Q1', 'Q2', 'Q3', 'Q4'])
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)

plt.tight_layout()
plt.show()
```

. . .

*> there are regular spikes in Q3!*

. . .

*> but there is also an increase over time*

---

## Model 5: Deseasonalization
<p class="subheader">We can remove seasonal patterns to see the trend more clearly.</p>

```{python}
# Visualization of deseasonalization
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose

# Set seed for reproducibility
np.random.seed(42)

# Generate quarterly data for 8 years (32 quarters)
n = 32
time = np.arange(n)
years = time // 4
quarters = time % 4

# Create a trend component
trend = 0.05 * time

# Create seasonal effects (Q1 typically low, Q3 typically high)
seasonal_pattern = np.array([-0.2, 0.1, 0.3, -0.1])  # Quarterly seasonal pattern
seasonal = np.array([seasonal_pattern[q] for q in quarters])

# Create a cyclical component (business cycle of ~5 years)
cycle = 0.3 * np.sin(2 * np.pi * time / 20)

# Add all components with some noise
series = trend + seasonal + cycle + 0.1 * np.random.normal(0, 1, n)
series = 100 * np.exp(series)  # Convert to exponential for more realistic scaling

# Convert to pandas Series for seasonal_decompose
ts = pd.Series(series)

# Apply seasonal decomposition
decomposition = seasonal_decompose(ts, model='multiplicative', period=4)

# Create figure for visualization
fig, axs = plt.subplots(4, 1, figsize=(11, 5))

# Plot original data
axs[0].plot(time, decomposition.observed, color='blue', linewidth=2)
axs[0].scatter(time, decomposition.observed, alpha=0.7, color='blue')
axs[0].set_title('Original Data', fontsize=14)
axs[0].set_xticks([])
axs[0].spines['top'].set_visible(False)
axs[0].spines['right'].set_visible(False)
axs[0].set_xticks([0,30])
axs[0].set_xlim(-1,30)
sns.despine(ax=axs[0], trim=True)

# Plot trend component
axs[1].plot(time, decomposition.trend, color='red', linewidth=2)
axs[1].set_title('Trend Component', fontsize=14)
axs[1].set_xticks([])
axs[1].spines['top'].set_visible(False)
axs[1].spines['right'].set_visible(False)
axs[1].set_xlim(-1,30)
axs[1].set_xticks([0,30])
sns.despine(ax=axs[1], trim=True)

# Plot seasonal component
axs[2].plot(time, decomposition.seasonal, color='green', linewidth=2)
axs[2].set_title('Seasonal Component', fontsize=14)
axs[2].set_xticks([])
axs[2].spines['top'].set_visible(False)
axs[2].spines['right'].set_visible(False)
axs[2].set_xlim(-1,30)
axs[2].set_xticks([0,30])
sns.despine(ax=axs[2], trim=True)

# Plot residual (random) component
axs[3].plot(time, decomposition.resid, color='purple', linewidth=2)
axs[3].scatter(time, decomposition.resid, alpha=0.7, color='purple')
axs[3].set_title('Residual Component', fontsize=14)
axs[3].set_xlabel('Time (Quarters)')
axs[3].spines['top'].set_visible(False)
axs[3].spines['right'].set_visible(False)

axs[3].set_xlim(-1,30)
sns.despine(ax=axs[3], trim=True)

plt.tight_layout()
plt.show()
```

. . .

*> seasonal decomposition separates trend, seasonal, and residual components*

---

## Model 5: Deseasonalization with Fixed Effects
<p class="subheader">Using seasonal dummies to adjust for quarterly patterns.</p>

```{python}
# Visualization of seasonal fixed effects in growth regression
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate data for 8 years (32 quarters)
n = 32
time = np.arange(n)
quarters = time % 4
years = time // 4

# Create seasonal effects using the same pattern from your example
seasonal_pattern = np.array([-0.2, 0.1, 0.3, -0.1])  # Quarterly seasonal pattern
seasonal = np.array([seasonal_pattern[q] for q in quarters])

# Generate X variable (e.g., income growth)
# Base growth rate + seasonal pattern + random noise
x_growth = 0.02 + 0.7 * seasonal + 0.03 * np.random.normal(0, 1, n)

# Generate Y variable (e.g., consumption growth)
# Depends on x_growth with a coefficient of 0.8 + seasonal pattern + random noise
slope = 0.8
y_growth = 0.01 + slope * x_growth + 0.5 * seasonal + 0.02 * np.random.normal(0, 1, n)

# Create a DataFrame for easier analysis
df = pd.DataFrame({
    'time': time,
    'quarter': quarters,
    'x_growth': x_growth,
    'y_growth': y_growth
})

# Create quarter dummy variables
for q in range(1, 4):  # Q1 is the reference category
    df[f'Q{q+1}'] = (df['quarter'] == q).astype(int)

# Run regression with seasonal fixed effects
X = sm.add_constant(df[['x_growth', 'Q2', 'Q3', 'Q4']])
model = sm.OLS(df['y_growth'], X).fit()

# Extract coefficients
intercept = model.params[0]
slope_coef = model.params[1]
q2_effect = model.params[2]
q3_effect = model.params[3]
q4_effect = model.params[4]

# Create figure
fig, ax = plt.subplots(figsize=(11, 5))

# Create a color palette for quarters
colors = ['#1f77b4', '#2ca02c', '#d62728', '#ff7f0e']  # blue, green, red, orange

# Plot scatter by quarter
for q in range(4):
    quarter_data = df[df['quarter'] == q]
    ax.scatter(quarter_data['x_growth'], quarter_data['y_growth'], 
               color=colors[q], alpha=0.7, s=80, 
               label=f'Q{q+1}')

# Plot regression lines for each quarter
x_range = np.linspace(df['x_growth'].min() - 0.01, df['x_growth'].max() + 0.01, 100)

# Add legend, labels and title
ax.legend(title='Quarter', fontsize=12)
ax.set_xlabel('X Growth Rate', fontsize=14)
ax.set_xlim(-0.2,0.3)
ax.set_ylabel('Y Growth Rate', fontsize=14)
ax.set_ylim(-0.3,0.4)

# Add grid and styling
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

sns.despine(trim=True)
plt.tight_layout()
plt.show()
```

---

## Model 5: Deseasonalization with Fixed Effects
<p class="subheader">Using seasonal dummies to adjust for quarterly patterns.</p>

```{python}
# Visualization of seasonal fixed effects in growth regression
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate data for 8 years (32 quarters)
n = 32
time = np.arange(n)
quarters = time % 4
years = time // 4

# Create seasonal effects using the same pattern from your example
seasonal_pattern = np.array([-0.2, 0.1, 0.3, -0.1])  # Quarterly seasonal pattern
seasonal = np.array([seasonal_pattern[q] for q in quarters])

# Generate X variable (e.g., income growth)
# Base growth rate + seasonal pattern + random noise
x_growth = 0.02 + 0.7 * seasonal + 0.03 * np.random.normal(0, 1, n)

# Generate Y variable (e.g., consumption growth)
# Depends on x_growth with a coefficient of 0.8 + seasonal pattern + random noise
slope = 0.8
y_growth = 0.01 + slope * x_growth + 0.5 * seasonal + 0.02 * np.random.normal(0, 1, n)

# Create a DataFrame for easier analysis
df = pd.DataFrame({
    'time': time,
    'quarter': quarters,
    'x_growth': x_growth,
    'y_growth': y_growth
})

# Create quarter dummy variables
for q in range(1, 4):  # Q1 is the reference category
    df[f'Q{q+1}'] = (df['quarter'] == q).astype(int)

# Run regression with seasonal fixed effects
X = sm.add_constant(df[['x_growth', 'Q2', 'Q3', 'Q4']])
model = sm.OLS(df['y_growth'], X).fit()

# Extract coefficients
intercept = model.params[0]
slope_coef = model.params[1]
q2_effect = model.params[2]
q3_effect = model.params[3]
q4_effect = model.params[4]

# Create figure
fig, ax = plt.subplots(figsize=(11, 5))

# Create a color palette for quarters
colors = ['#1f77b4', '#2ca02c', '#d62728', '#ff7f0e']  # blue, green, red, orange

# Plot scatter by quarter
for q in range(4):
    quarter_data = df[df['quarter'] == q]
    ax.scatter(quarter_data['x_growth'], quarter_data['y_growth'], 
               color=colors[q], alpha=0.7, s=80, 
               label=f'Q{q+1}')

# Plot regression lines for each quarter
x_range = np.linspace(df['x_growth'].min() - 0.01, df['x_growth'].max() + 0.01, 100)

# Q1 line (base intercept)
ax.plot(x_range, intercept + slope_coef * x_range, 
        color=colors[0], linewidth=2, linestyle='-')

# Q2 line
ax.plot(x_range, (intercept + q2_effect) + slope_coef * x_range, 
        color=colors[1], linewidth=2, linestyle='-')

# Q3 line
ax.plot(x_range, (intercept + q3_effect) + slope_coef * x_range, 
        color=colors[2], linewidth=2, linestyle='-')

# Q4 line
ax.plot(x_range, (intercept + q4_effect) + slope_coef * x_range, 
        color=colors[3], linewidth=2, linestyle='-')

# Add legend, labels and title
ax.legend(title='Quarter', fontsize=12)
ax.set_xlabel('X Growth Rate', fontsize=14)
ax.set_xlim(-0.2,0.3)
ax.set_ylabel('Y Growth Rate', fontsize=14)
ax.set_ylim(-0.3,0.4)

# Add grid and styling
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

sns.despine(trim=True)
plt.tight_layout()
plt.show()
```

---

## Model 5: Deseasonalization with Fixed Effects
<p class="subheader">Using seasonal dummies to adjust for quarterly patterns.</p>

```{python}
# Visualization of seasonal fixed effects with intercept visualization
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import statsmodels.api as sm

# Set seed for reproducibility
np.random.seed(42)

# Generate data for 8 years (32 quarters)
n = 32
time = np.arange(n)
quarters = time % 4
years = time // 4

# Create seasonal effects using the same pattern
seasonal_pattern = np.array([-0.2, 0.1, 0.3, -0.1])  # Quarterly seasonal pattern
seasonal = np.array([seasonal_pattern[q] for q in quarters])

# Generate X variable (e.g., income growth)
# Base growth rate + seasonal pattern + random noise
x_growth = 0.02 + 0.7 * seasonal + 0.03 * np.random.normal(0, 1, n)

# Generate Y variable (e.g., consumption growth)
# Depends on x_growth with a coefficient of 0.8 + seasonal pattern + random noise
slope = 0.8
y_growth = 0.01 + slope * x_growth + 0.5 * seasonal + 0.02 * np.random.normal(0, 1, n)

# Create a DataFrame for easier analysis
df = pd.DataFrame({
    'time': time,
    'quarter': quarters,
    'x_growth': x_growth,
    'y_growth': y_growth
})

# Create quarter dummy variables
for q in range(1, 4):  # Q1 is the reference category
    df[f'Q{q+1}'] = (df['quarter'] == q).astype(int)

# Run regression with seasonal fixed effects
X = sm.add_constant(df[['x_growth', 'Q2', 'Q3', 'Q4']])
model = sm.OLS(df['y_growth'], X).fit()

# Extract coefficients
intercept = model.params[0]
slope_coef = model.params[1]
q2_effect = model.params[2]
q3_effect = model.params[3]
q4_effect = model.params[4]

# Calculate intercepts for each quarter
q1_intercept = intercept
q2_intercept = intercept + q2_effect
q3_intercept = intercept + q3_effect
q4_intercept = intercept + q4_effect

# Create figure
fig, axs = plt.subplots(1, 2, figsize=(11.5, 5), gridspec_kw={'width_ratios': [3, 1]})

# Main plot (scatter and regression lines)
ax = axs[0]

# Create a color palette for quarters
colors = ['#1f77b4', '#2ca02c', '#d62728', '#ff7f0e']  # blue, green, red, orange

# Plot scatter by quarter
for q in range(4):
    quarter_data = df[df['quarter'] == q]
    ax.scatter(quarter_data['x_growth'], quarter_data['y_growth'], 
               color=colors[q], alpha=0.7, s=80, 
               label=f'Q{q+1}')

# Plot regression lines for each quarter
x_range = np.linspace(df['x_growth'].min() - 0.01, df['x_growth'].max() + 0.01, 100)

# Plot line for x=0 to show intercepts
ax.axvline(x=0, color='black', linestyle='--', alpha=0.3)

# Q1 line (base intercept)
ax.plot(x_range, intercept + slope_coef * x_range, 
        color=colors[0], linewidth=2, linestyle='-')

# Q2 line
ax.plot(x_range, (intercept + q2_effect) + slope_coef * x_range, 
        color=colors[1], linewidth=2, linestyle='-')

# Q3 line
ax.plot(x_range, (intercept + q3_effect) + slope_coef * x_range, 
        color=colors[2], linewidth=2, linestyle='-')

# Q4 line
ax.plot(x_range, (intercept + q4_effect) + slope_coef * x_range, 
        color=colors[3], linewidth=2, linestyle='-')

# Mark intercepts at x=0
ax.scatter([0], [q1_intercept], color='white', s=100, zorder=10, edgecolor='black')
ax.scatter([0], [q2_intercept], color='white', s=100, zorder=10, edgecolor='black')
ax.scatter([0], [q3_intercept], color='white', s=100, zorder=10, edgecolor='black')
ax.scatter([0], [q4_intercept], color='white', s=100, zorder=10, edgecolor='black')

# Connect intercepts with dotted line
ax.plot([0, 0], [q1_intercept, q4_intercept], 'k:', alpha=0.5)

# Annotate intercepts
ax.annotate(f'{q1_intercept:.3f}', xy=(0, q1_intercept), xytext=(-0.08, q1_intercept),
            fontsize=11, color=colors[0], va='center', ha='right',
            bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.7))

ax.annotate(f'{q2_intercept:.3f}', xy=(0, q2_intercept), xytext=(-0.08, q2_intercept),
            fontsize=11, color=colors[1], va='center', ha='right',
            bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.7))

ax.annotate(f'{q3_intercept:.3f}', xy=(0, q3_intercept), xytext=(-0.08, q3_intercept),
            fontsize=11, color=colors[2], va='center', ha='right',
            bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.7))

ax.annotate(f'{q4_intercept:.3f}', xy=(0, q4_intercept), xytext=(-0.08, q4_intercept),
            fontsize=11, color=colors[3], va='center', ha='right',
            bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.7))

# Add legend, labels and title
ax.legend(title='Quarter', fontsize=12, loc='upper left')
ax.set_xlabel('X Growth Rate', fontsize=14)
ax.set_ylabel('Y Growth Rate', fontsize=14)
ax.set_xlim(-0.2, 0.3)
ax.set_ylim(-0.3, 0.4)

# Add text annotation for slope
ax.text(0.05, -0.25, f"Common slope: {slope_coef:.2f}", fontsize=12,
        bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.7))

# Add styling
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

sns.despine(ax=ax, trim=True)

# Right panel: Bar chart of seasonal effects
ax2 = axs[1]

# Create bar chart of intercepts
quarters = ['Q1', 'Q2', 'Q3', 'Q4']
intercepts = [q1_intercept, q2_intercept, q3_intercept, q4_intercept]

# Plot bars
bars = ax2.bar(quarters, intercepts, color=colors, alpha=0.7, edgecolor='black')

# Add value labels on top of each bar
for c, bar in zip(colors, bars):
    height = bar.get_height()
    if height < 0:
        va_ = 'top'
        pad = -0.01
    else:
        va_ = 'bottom'
        pad = 0.01
    ax2.text(bar.get_x() + bar.get_width()/2., height + pad,
            f'{height:.3f}', ha='center', va=va_, fontsize=11)

    ax.plot([-0.2, 0.3], [height, height], c, alpha=0.1)

# Add title and labels
ax2.set_title('Quarterly Intercepts', fontsize=14)
ax2.spines['top'].set_visible(False)
ax2.spines['right'].set_visible(False)
ax2.set_ylim(-0.3, 0.4)

sns.despine(ax=ax2, trim=True)

# Adjust layout
plt.tight_layout()
plt.show()
```

. . .

*> using these fixed effects deseasonalizes the data*

. . .

*> the slope captures the trend consistent across quarters*

---

## Model 5: Implementing Seasonal Fixed Effects
<p class="subheader">Deseasonalizing data through regression.</p>

```python
# Run regression with seasonal dummies using C() notation
model5 = smf.ols('gdp_growth ~ unemployment_growth + C(quarter)', data=data).fit()
```

<br>

. . .

*> deseasonalized data removes the average effect of each season*

. . .

*> relationship between variables is now clearer without seasonal distortions*

---

## Key Takeaways
<p class="subheader">Best practices for time series analysis in economics.</p>

<br>

1. **Use differences or growth rates**
   - Reduces serial correlation and removes trends
   - First differences focus on period-to-period changes

. . .

2. **Address seasonality explicitly**
   - Seasonal dummies, year-over-year comparisons

. . .

3. **Combine methods when appropriate**
   - Growth rates of seasonally adjusted data

. . .

*> time series analysis requires special care but yields valuable economic insights*