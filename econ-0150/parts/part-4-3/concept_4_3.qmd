---
format:
  revealjs:
    css: custom.css
    transition: none
    aspect-ratio: "16:9"
---

## ECON 0150 | Economic Data Analysis {.center}
<p class="subheader">The economist's data analysis workflow.</p>

<br> 

### *Part 4.3 | Categorical Predictors*

---

## General Linear Model
<p class="subheader">... a flexible approach to run many statistical tests.</p>

**The Linear Model**: $y_i = \beta_0 + \beta_1 x_i + \varepsilon_i$

. . .

- $\beta_0$ is the intercept (value of $\bar{y}$ when x = 0)
- $\beta_1$ is the slope (change in y per unit change in x)
- $\varepsilon_i$ is the error term (random noise around the model)

. . .

**OLS Estimation**: Minimizes $\sum_{i=1}^n \varepsilon_i^2$

---

## GLM: Intercept Model
<p class="subheader">A one-sample t-test is a horizontal line model.</p>

```{python}
#| echo: false
#| fig-align: center
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set random seed for reproducibility
np.random.seed(42)

# Generate sample data
n = 30
data = [1.3, 2.4, 2.2, 1.3, 3.0, 2.3, 0.8, 2.7, 2.0, 2.9, 1.7, 1.9, 2.2,
       2.1, 2.4, 1.7, 1.7, 1.9, 1.7, 2.5, 2.4, 2.2, 1.9, 1.9, 2.7, 1.8,
       1.8, 2.0, 1.9, 2.1]

# Create the plot
plt.figure(figsize=(11, 3))

# Plot the data points
plt.scatter(range(1, n+1), data, alpha=0.7, label='Data Points')

# Plot the horizontal line at the mean
mean_data = np.mean(data)
plt.axhline(mean_data, color='r', linestyle='-', linewidth=2, label=f'Mean ($\\beta_0$ = {mean_data:.2f})')

# Add vertical lines for errors
for i in range(n):
    plt.plot([i+1, i+1], [data[i], mean_data], 'g--', alpha=0.4)

plt.ylabel('Temperature Difference (°C)', fontsize=16)
plt.grid(False)
plt.legend()
plt.xticks([])
sns.despine(bottom=True, trim=True)

plt.tight_layout()
```

$$Temperature = \beta_0 + \varepsilon$$

. . .

*> the intercept $\beta_0$ is the estimated mean temperature*

. . .

*> the p-value is the probability of seeing $\beta_0$ if the null is true*

---

## GLM: Intercept + Slope
<p class="subheader">A regression is a test of relationships.</p>

```{python}
#| echo: false
#| fig-align: center
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import pandas as pd

# Update Matplotlib parameters
plt.rcParams.update({
    'font.family': 'serif',              # Set the font family
    'font.serif': ['Times New Roman'],   # Use a specific serif font
    'font.style': 'italic',              # Set the font style to italic
})

# Set a seed for reproducibility
np.random.seed(42)

# Generate wait times dataset
n = 60
minutes_after_open = np.linspace(0, 600, n)  # 0 to 600 minutes
wait_times = 5 + 0.01 * minutes_after_open + np.random.normal(0, 2, n)  # Base wait + trend + noise
wait_times = np.maximum(0, wait_times)  # Ensure no negative wait times

# Fit regression models
slope, intercept, r_value, p_value, std_err = stats.linregress(minutes_after_open, wait_times)
mean_wait = np.mean(wait_times)

# Calculate MSE for both models
mse_mean = np.mean((wait_times - mean_wait)**2)
mse_regression = np.mean((wait_times - (intercept + slope * minutes_after_open))**2)

# Create a figure with two subplots
fig, ax2 = plt.subplots(1, 1, figsize=(11, 3))

# Plot 2: Linear regression model
ax2.scatter(minutes_after_open, wait_times, alpha=0.7)
x_line = np.array([min(minutes_after_open), max(minutes_after_open)])
y_line = intercept + slope * x_line
ax2.plot(x_line, y_line, 'r-', linewidth=2)

# Add vertical error lines for regression model
for i in range(0, n, 1):  # Show errors for every 5th point
    y_pred = intercept + slope * minutes_after_open[i]
    ax2.plot([minutes_after_open[i], minutes_after_open[i]], 
             [wait_times[i], y_pred], 'green', linestyle=':', alpha=0.5)

ax2.set_xlabel('Minutes After Opening', fontsize=14)
ax2.set_ylabel('Wait Time', fontsize=14)
ax2.legend()

# Use the same styling as your other plots
sns.despine(ax=ax2, left=False, bottom=False, right=True, top=True, trim=True)
plt.tight_layout()
plt.show()
```

$$\text{WaitTime} = \beta_0 + \beta_1 \text{MinutesAfterOpening} + \epsilon$$

. . .

*> the intercept parameter $\beta_0$ is the estimated temperature at 0 on the horizontal*

. . .

*> the slope parameter $\beta_1$ is the estimated change in y for a 1 unit change in x*

. . .

*> the p-value is the probability of seeing parameter ($\beta_0$ or $\beta_1$) if the null is true*

---

## GLM: City Greenspace and Temperature
<p class="subheader">Q. Is temperature lower in neighborhoods with more green space?</p>

```{python}
#| echo: false
#| fig-align: center
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set seed for reproducibility
np.random.seed(42)

# Create 50 data points for each group
n = 50
low_green = 22 + np.random.normal(0, 1.5, n)  # Higher temperatures
high_green = 19 + np.random.normal(0, 1.5, n)  # Lower temperatures
jitter = np.random.uniform(-0.1,0.1,2*n)

# Combine into a dataframe
data = pd.DataFrame({
    'temperature': np.concatenate([low_green, high_green]),
    'high_green': np.concatenate([np.zeros(n), np.ones(n)])
})

# Plot the data
plt.figure(figsize=(11, 4))
sns.boxplot(x='high_green', y='temperature', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)
plt.scatter(data['high_green']+jitter, data['temperature'], alpha=0.4, color='darkblue')

plt.xticks([0, 1], ['0\n(No)', '1\n(Yes)'])
plt.ylabel('Temperature (°C)', fontsize=14)
plt.xlabel('High Greenspace', fontsize=14)

plt.xlim(-0.5,1.5)
sns.despine(trim=True)
plt.tight_layout()
```

. . .

*Q. Does temperature change as we move out on the horizontal axis?*

. . .

$$Temperature = \beta_0 + \beta_1 \cdot HighGreen + \varepsilon$$

. . .

*> the GLM performs a t-test on $\beta_1$, whether the difference is significant*

---

## GLM: City Greenspace and Temperature
<p class="subheader">Q. Does temperature change as we move out on the horizontal axis?</p>

```{python}
#| echo: false
#| fig-align: center
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set seed for reproducibility
np.random.seed(42)

# Create 50 data points for each group
n = 50
low_green = 22 + np.random.normal(0, 1.5, n)  # Higher temperatures
high_green = 19 + np.random.normal(0, 1.5, n)  # Lower temperatures
jitter = np.random.uniform(-0.1,0.1,2*n)

# Combine into a dataframe
data = pd.DataFrame({
    'temperature': np.concatenate([low_green, high_green]),
    'high_green': np.concatenate([np.zeros(n), np.ones(n)])
})

# Plot the data
plt.figure(figsize=(11, 4))
sns.boxplot(x='high_green', y='temperature', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)
plt.scatter(data['high_green']+jitter, data['temperature'], alpha=0.4, color='darkblue')

# Calculate and display the means
mean_low = np.mean(low_green)
mean_high = np.mean(high_green)
plt.plot([0, 1], [mean_low, mean_high], 'r-', linewidth=2)

plt.xticks([0, 1], ['0\n(No)', '1\n(Yes)'])
plt.ylabel('Temperature (°C)', fontsize=14)
plt.xlabel('High Greenspace', fontsize=14)

plt.text(-0.35, mean_low, f'$\\beta_0$ = {mean_low:.2f}°C', fontsize=12, va='center')
plt.text(1.15, mean_high, f'$\\beta_0$ + $\\beta_1$ = {mean_high:.2f}°C', fontsize=12, va='center')
plt.text(0.5, (mean_low+mean_high)/2+0.5, f'$\\beta_1$ = {mean_high-mean_low:.2f}°C', fontsize=12, va='center', ha='center', rotation=-8)

plt.xlim(-0.5,1.5)
sns.despine(trim=True)
plt.tight_layout()
```

$$Temperature = \beta_0 + \beta_1 \cdot HighGreen + \varepsilon$$

. . .

How would we interpret $\beta_0$ here?

. . .

*> $\beta_0$ is the mean temperature in ($x=0$) low green space cities (22.03°C)*

---

## GLM: City Greenspace and Temperature
<p class="subheader">Q. Does temperature change as we move out on the horizontal axis?</p>

```{python}
#| echo: false
#| fig-align: center
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set seed for reproducibility
np.random.seed(42)

# Create 50 data points for each group
n = 50
low_green = 22 + np.random.normal(0, 1.5, n)  # Higher temperatures
high_green = 19 + np.random.normal(0, 1.5, n)  # Lower temperatures
jitter = np.random.uniform(-0.1,0.1,2*n)

# Combine into a dataframe
data = pd.DataFrame({
    'temperature': np.concatenate([low_green, high_green]),
    'high_green': np.concatenate([np.zeros(n), np.ones(n)])
})

# Plot the data
plt.figure(figsize=(11, 4))
sns.boxplot(x='high_green', y='temperature', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)
plt.scatter(data['high_green']+jitter, data['temperature'], alpha=0.4, color='darkblue')

# Calculate and display the means
mean_low = np.mean(low_green)
mean_high = np.mean(high_green)
plt.plot([0, 1], [mean_low, mean_high], 'r-', linewidth=2)

plt.xticks([0, 1], ['0\n(No)', '1\n(Yes)'])
plt.ylabel('Temperature (°C)', fontsize=14)
plt.xlabel('High Greenspace', fontsize=14)

plt.text(-0.35, mean_low, f'$\\beta_0$ = {mean_low:.2f}°C', fontsize=12, va='center')
plt.text(1.15, mean_high, f'$\\beta_0$ + $\\beta_1$ = {mean_high:.2f}°C', fontsize=12, va='center')
plt.text(0.5, (mean_low+mean_high)/2+0.5, f'$\\beta_1$ = {mean_high-mean_low:.2f}°C', fontsize=12, va='center', ha='center', rotation=-8)

plt.xlim(-0.5,1.5)
sns.despine(trim=True)
plt.tight_layout()
```

$$Temperature = \beta_0 + \beta_1 \cdot HighGreen + \varepsilon$$

. . .

How would we interpret $\beta_1$ here?

. . .

*> Cities with Green Space (x=1) have a temperature that is lower by $\beta_1$*

. . .

*> ie. a one unit increase in $x$ changes temperature by $\beta_1$*


---

## GLM: City Greenspace and Temperature
<p class="subheader">Q. Does temperature change as we move out on the horizontal axis?</p>

```{python}
#| echo: false
#| fig-align: center
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Set seed for reproducibility
np.random.seed(42)

# Create 50 data points for each group
n = 50
low_green = 22 + np.random.normal(0, 1.5, n)  # Higher temperatures
high_green = 19 + np.random.normal(0, 1.5, n)  # Lower temperatures
jitter = np.random.uniform(-0.1,0.1,2*n)

# Combine into a dataframe
data = pd.DataFrame({
    'temperature': np.concatenate([low_green, high_green]),
    'high_green': np.concatenate([np.zeros(n), np.ones(n)])
})

# Plot the data
plt.figure(figsize=(11, 4))

sns.boxplot(x='high_green', y='temperature', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)

plt.scatter(data['high_green']+jitter, data['temperature'], alpha=0.4, color='darkblue')

# Calculate and display the means
mean_low = np.mean(low_green)
mean_high = np.mean(high_green)

# Calculate standard error for the difference in means
pooled_std = np.sqrt(((n-1)*np.var(low_green, ddof=1) + (n-1)*np.var(high_green, ddof=1)) / (2*n - 2))
se_diff = pooled_std * np.sqrt(1/n + 1/n)

# Draw random samples under null hypothesis (no difference)
n_samples = 100
np.random.seed(42)
for i in range(n_samples):
    # Random slope centered on 0 with appropriate standard error
    random_slope = np.random.normal(0, se_diff*1.5)
    random_high = mean_low + random_slope
    plt.plot([0, 1], [mean_low, random_high], 'grey', alpha=0.1, linewidth=0.8)

# Plot the observed difference (on top)
plt.plot([0, 1], [mean_low, mean_high], 'r-', linewidth=2, label='Observed difference')

plt.xticks([0, 1], ['0\n(No)', '1\n(Yes)'])
plt.ylabel('Temperature (°C)', fontsize=14)
plt.xlabel('High Greenspace', fontsize=14)

plt.text(-0.35, mean_low, f'$\\beta_0$ = {mean_low:.2f}°C', fontsize=12, va='center')
plt.text(1.15, mean_high, f'$\\beta_0$ + $\\beta_1$ = {mean_high:.2f}°C', fontsize=12, va='center')
plt.text(0.5, (mean_low+mean_high)/2+0.5, f'$\\beta_1$ = {mean_high-mean_low:.2f}°C', fontsize=12, va='center', ha='center', rotation=-8)

# Add text explaining the null distribution
plt.text(0.5, 23.5, 'Grey lines: possible samples under the null (no difference)', 
         fontsize=10, ha='center', style='italic', color='gray')

plt.xlim(-0.5,1.5)
sns.despine(trim=True)
plt.tight_layout()
```

. . .

*> p-value on $\beta_1$: probability of a slope as extreme as $\beta_1$ under the null dist*

---

## Exercise: Neighborhood Income and Pollution
<p class="subheader">Do low-income neighborhoods face higher pollution levels?</p>

**Step 1: Summarize the data**

. . .

<br>

```python
# Visualize Binary Predictor
sns.scatterplot(data, x='low_income', y='pollution')
plt.xticks([0,1], labels=['No', 'Yes'])
```

. . .

```{python}
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
# Set seed for reproducibility
np.random.seed(42)
# Create 40 data points for each group
n = 40
high_income = 25 + np.random.normal(0, 5, n)  # Lower pollution
low_income = 40 + np.random.normal(0, 7, n)   # Higher pollution
jitter = np.random.uniform(-0.1,0.1,2*n)
# Combine into a dataframe
data = pd.DataFrame({
    'pollution': np.concatenate([high_income, low_income]),
    'low_income': np.concatenate([np.zeros(n), np.ones(n)])
})
# Plot the data
plt.figure(figsize=(11, 4))
sns.boxplot(x='low_income', y='pollution', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)
plt.scatter(data['low_income']+jitter, data['pollution'], alpha=0.4, color='darkblue')

plt.xticks([0, 1], ['High Income\n(0)', 'Low Income\n(1)'])
plt.ylabel('Air Pollution Index', fontsize=14)

plt.xlim(-0.5,1.5)
sns.despine(trim=True)
plt.tight_layout()
```


---

## Exercise: Neighborhood Income and Pollution
<p class="subheader">Do low-income neighborhoods face higher pollution levels?</p>

**Step 2: Build a model**

. . .

$$Pollution = \beta_0 + \beta_1 \cdot LowIncome + \varepsilon$$

---

## Exercise: Neighborhood Income and Pollution
<p class="subheader">Do low-income neighborhoods face higher pollution levels?</p>

**Step 3: Estimate the model**

. . .

```{python}
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
# Set seed for reproducibility
np.random.seed(42)
# Create 40 data points for each group
n = 40
high_income = 25 + np.random.normal(0, 5, n)  # Lower pollution
low_income = 40 + np.random.normal(0, 7, n)   # Higher pollution
jitter = np.random.uniform(-0.1,0.1,2*n)
# Combine into a dataframe
data = pd.DataFrame({
    'pollution': np.concatenate([high_income, low_income]),
    'low_income': np.concatenate([np.zeros(n), np.ones(n)])
})
# Plot the data
plt.figure(figsize=(11, 4))
sns.boxplot(x='low_income', y='pollution', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)
plt.scatter(data['low_income']+jitter, data['pollution'], alpha=0.4, color='darkblue')
# Calculate and display the means
mean_high = np.mean(high_income)
mean_low = np.mean(low_income)
plt.plot([0, 1], [mean_high, mean_low], 'r-', linewidth=2)
plt.xticks([0, 1], ['High Income\n(0)', 'Low Income\n(1)'])
plt.ylabel('Air Pollution Index', fontsize=14)
plt.text(-0.35, mean_high, f'$\\beta_0$ = {mean_high:.1f}', fontsize=12, va='center')
plt.text(1.15, mean_low, f'$\\beta_0$ + $\\beta_1$ = {mean_low:.1f}', fontsize=12, va='center')
plt.text(0.5, (mean_high+mean_low)/2+5, f'$\\beta_1$ = {mean_low-mean_high:.1f}', fontsize=12, va='center')
plt.xlim(-0.5, 1.5)
sns.despine(trim=True)
plt.tight_layout()
```

. . .

```python
# Model: y = b + mx
model = smf.ols('pollution ~ low_income', data).fit() # Intercept is included by default
print(model.summary().tables[1])
```

. . .

- $\beta_0$ = Mean pollution in high-income areas (23.9)

- $\beta_1$ = Additional pollution in low-income areas (15.9)

---

## Exercise: Neighborhood Income and Pollution
<p class="subheader">Do low-income neighborhoods face higher pollution levels?</p>

**Step 4: Check the residuals**

```python
sns.scatterplot(x=model.predict(), y=model.resid, alpha=0.5)
plt.axhline(y=0, color='red', linestyle='-')
plt.xlabel('Fitted Values')
plt.ylabel('Residuals')
```

---

## Exercise: Neighborhood Income and Pollution
<p class="subheader">Do low-income neighborhoods face higher pollution levels?</p>

**Step 5: Interpret and communicate the findings**

```{python}
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
# Set seed for reproducibility
np.random.seed(42)
# Create 40 data points for each group
n = 40
high_income = 25 + np.random.normal(0, 5, n)  # Lower pollution
low_income = 40 + np.random.normal(0, 7, n)   # Higher pollution
jitter = np.random.uniform(-0.1,0.1,2*n)
# Combine into a dataframe
data = pd.DataFrame({
    'pollution': np.concatenate([high_income, low_income]),
    'low_income': np.concatenate([np.zeros(n), np.ones(n)])
})
# Plot the data
plt.figure(figsize=(11, 4))
sns.boxplot(x='low_income', y='pollution', data=data, 
            color='white',  # Use white for the boxes
            width=0.2,
            zorder=-1)
plt.scatter(data['low_income']+jitter, data['pollution'], alpha=0.4, color='darkblue')
# Calculate and display the means
mean_high = np.mean(high_income)
mean_low = np.mean(low_income)
plt.plot([0, 1], [mean_high, mean_low], 'r-', linewidth=2)
plt.xticks([0, 1], ['High Income\n(0)', 'Low Income\n(1)'])
plt.ylabel('Air Pollution Index', fontsize=14)
plt.text(-0.35, mean_high, f'$\\beta_0$ = {mean_high:.1f}', fontsize=12, va='center')
plt.text(1.15, mean_low, f'$\\beta_0$ + $\\beta_1$ = {mean_low:.1f}', fontsize=12, va='center')
plt.text(0.5, (mean_high+mean_low)/2+5, f'$\\beta_1$ = {mean_low-mean_high:.1f}', fontsize=12, va='center')
plt.xlim(-0.5, 1.5)
sns.despine(trim=True)
plt.tight_layout()
```

. . .

*> A significant positive $\beta_1$ suggests environmental quality differences between neighborhoods*

---

## GLM: Summary *(so far)*
<p class="subheader">GLM's unified framework for testing statistical models</p>

. . .

**One-Sample T-Test**: Continuous outcome variable ($y$) with only an intercept

$$y = \beta_0 + \varepsilon$$

. . .

**Relationships**: Continuous outcome variable ($y$) with a continuous predictor ($x$)

$$y = \beta_0 + \beta_1 x + \varepsilon$$

. . .

**Two-Sample T-Test**: Continuous outcome variable ($y$) with a dummy ($Group$)

$$y = \beta_0 + \beta_1 \cdot Group + \varepsilon$$

. . .

**Multiple Regression**: Adding control variables to isolate relationships

. . .

<br>

*> all use the same OLS framework and interpretation of coefficients and p-values*
